%assign SYS_EXIT 1
%assign SYS_WRITE 4
%assign STDOUT 1

section .data ;tell linker data section
    x db 123 ;x = 123
    msgX db "x = " ;message

section .text ;tell linker text section
    global _start ;tell linker entry point

_start: ;entry point
    mov ecx, msgX ;move address of msgX to ecx
    mov edx, 4 ;move length of msgX to edx
    call _printString ;call printString
    mov eax, 0 ;move 0 to eax
    mov al, byte[x] ;move x to al
    call _printDec ;call printDec
    mov ebx, 0 ;move 0 to ebx
    mov eax, 1 ;move 1 to eax
    int 0x80 ;call kernel

_printString: ;printString function
    push eax ;save eax
    push ebx ;save ebx
    mov eax,SYS_WRITE ;move SYS_WRITE to eax
    mov ebx,STDOUT ;move STDOUT to ebx
    int 0x80 ;call kernel
    pop ebx ;restore ebx
    pop eax ;restore eax
    ret ;return

_println:
    section .data ;tell linker data section
    .nl db 10 ;newline
    section .text ;tell linker text section
    push ecx ;save ecx
    push edx ;save edx
    mov ecx, .nl ;move address of .nl to ecx
    mov edx, 1 ;move length of .nl to edx
    call _printString ;call printString
    pop edx ;restore edx
    pop ecx ;restore ecx
    ret ;return

_printDec:
    ;;;saves all the registers so that they are not changed by the function
    section .bss
    .decstr resb 10
    .ct1 resd 1 ;to keep track of the size of the string
    section .text
    pushad ;save all registers
    mov dword[.ct1],0 ;assume initially 0
    mov edi,.decstr ;edi points to decstring
    add edi,9 ;moved to the last element of string
    xor edx,edx ;clear edx for 64-bit division
    .whileNotZero:
    mov ebx,10 ;get ready to divide by 10
    div ebx ;divide by 10
    add edx,'0' ;converts to ascii char
    mov byte[edi],dl ;put it in sring
    dec edi ;mov to next char in string
    inc dword[.ct1] ;increment char counter
    xor edx,edx ;clear edx
    cmp eax,0 ;is remainder of division 0?
    jne .whileNotZero ;no, keep on looping
    inc edi ;conversion, finish, bring edi
    mov ecx, edi ;back to beg of string. make ecx
    mov edx, [.ct1] ;point to it, and edx gets # chars
    mov eax, SYS_WRITE ;and print!
    mov ebx, STDOUT ;print to stdout
    int 0x80 ;call the kernel
    popad ;restore all registers
    ret
